---
title: "Inflern 스프링 입문(김영한) - Spring의 DB 접근 기술(5)"
categories:
  - Java/Spring
tags:
  - Inflern 스프링 입문(김영한)

toc: true
toc_sticky : true

date : 2023-08-21
last_modified_at : 2023-08-21
---

> 해당 글은 기존 Velog로부터 새롭게 Github Blog로 이전되었습니다.

# Spring의 DB 접근 기술

## H2 DataBase

- Java SQL Database
- 빠르고 오픈소스인 JDBC API
- 가볍고 설치가 쉬우며 관리가 편리
- 설치
    - [https://www.h2database.com](https://www.h2database.com/html/main.html) 를 통해 다운로드
    - Linux 및 MAC OS는 권한 부여 필요 → `chmod 755 h2.sh` 및 `./h2.sh` 를 통해 실행
- db 파일 생성 방법
    - JDBC URL에 jdbc:h2:~/test 확인 및 연결→ ~/test.mv.db 파일 생성 확인 → 최초 파일 생성 이후부터는 jdbc:h2:tcp://localhost/~/test 이렇게 접속(파일로 접근시 웹 콘솔과 어플리케이션 간에 충돌이 일어날 수 있으므로 다음과 같이 소켓을 통해 접근)
- Table 생성 방법
    
    ```sql
    create table member //member 테이블 생성
    (
        id   bigint generated by default as identity, //id
    		// bigint -> Long 
    		// generated by default as identity -> null로 값이 들어오면 DB에서 부여
        name varchar(255), //이름
        primary key (id) //id를 기본키로 지정
    );
    ```
    

## 순수 JDBC로 연결

- JDBC API로 직접 코딩하는 것은 20년 전 이야기 → 고대 개발자들이 이렇게
고생하고 살았구나 생각하고, 정신건강을 위해 참고만 하고 넘어갈 것
- Spring의 DI (Dependencies Injection)을 사용하면 기존 코드를 전혀 손대지 않고, Configuration만으로 구현 클래스를 변경할 수 있음 → 개방-폐쇄 원칙(OCP, Open-Closed Principle)
- build.gradle 파일에 jdbc, h2 데이터베이스 관련 라이브러리 추가
    
    ```kotlin
    dependencies {
    	implementation("org.springframework.boot:spring-boot-starter-jdbc")
    	runtimeOnly("com.h2database:h2")
    }
    ```
    
- resources/application.properties 에 DB 연결 설정 추가
    
    ```
    spring.datasource.url=jdbc:h2:tcp://localhost/~/test
    # DB URL
    spring.datasource.driver-class-name=org.h2.Driver
    # DB Driver
    spring.datasource.username=sa
    # Spring Boot 2.4부터는 추가하지 않으면 오류가 발생
    ```
    
- Jdbc Repository 구현
    
    ```java
    package com.example.demo.repository;
    
    public class JdbcMemberRepository implements MemberRepository{
    
        private final DataSource dataSource; //Spring을 통해 주입 받을 DataSource
    
        //DataSource를 주입 받고 DB와 연결, 이후에 SQL문을 담아 전달
    
        public JdbcMemberRepository(DataSource dataSource) {
            //DataSource를 주입 받고 DB와 연결, 이후에 SQL문을 담아 전달
            this.dataSource = dataSource;
        }
    
        @Override
        public Member save(Member member) {
            String sql = "insert into member(name) values(?)";
    
            Connection conn = null;
            PreparedStatement pstmt = null;
            ResultSet rs = null;
    
            try {
                conn = getConnection(); //DB와 연결
                pstmt = conn.prepareStatement(sql,
                        Statement.RETURN_GENERATED_KEYS);
                pstmt.setString(1, member.getName());
                //values(?) 파마리터 부분에 이름 주입
    
                pstmt.executeUpdate(); //실제 쿼리 발송 -> 데이터 저장
                rs = pstmt.getGeneratedKeys(); //DB 생성된 key에 따라 값을 반환
    
                if (rs.next()) { //ResultSet에 값이 존재할 경우
                    member.setId(rs.getLong(1)); //id를 가져와 객체에 넣음
                } else {
                    throw new SQLException("id 조회 실패");
                }
                return member;
            } catch (Exception e) {
                throw new IllegalStateException(e);
            } finally {
                close(conn, pstmt, rs); //DB Connection을 닫음
            }
        }
        @Override
        public Optional<Member> findById(Long id) {
            String sql = "select * from member where id = ?";
    
            Connection conn = null;
            PreparedStatement pstmt = null;
    
            ResultSet rs = null;
            try {
                conn = getConnection();
                pstmt = conn.prepareStatement(sql);
                pstmt.setLong(1, id);
    
                rs = pstmt.executeQuery(); //데이터 조회
    
                if(rs.next()) { //값이 존재할 경우
    
                    // member 객체 생성
                    Member member = new Member();
                    member.setId(rs.getLong("id"));
                    member.setName(rs.getString("name"));
    
                    return Optional.of(member);
                } else {
                    return Optional.empty();
                }
            } catch (Exception e) {
                throw new IllegalStateException(e);
            } finally {
                close(conn, pstmt, rs);
            } }
        @Override
        public List<Member> findAll() {
            String sql = "select * from member";
    
            Connection conn = null;
            PreparedStatement pstmt = null;
            ResultSet rs = null;
    
            try {
    
                conn = getConnection();
                pstmt = conn.prepareStatement(sql);
                rs = pstmt.executeQuery();
    
                List<Member> members = new ArrayList<>();
    
                while(rs.next()) {
                    Member member = new Member();
                    member.setId(rs.getLong("id"));
                    member.setName(rs.getString("name"));
                    members.add(member);
                }
                //멤버를 리스트에 담아서 반환
    
                return members;
            } catch (Exception e) {
                throw new IllegalStateException(e);
            } finally {
                close(conn, pstmt, rs);
            }
        }
        @Override
        public Optional<Member> findByName(String name) {
            String sql = "select * from member where name = ?";
            Connection conn = null;
            PreparedStatement pstmt = null;
            ResultSet rs = null;
            try {
                conn = getConnection();
                pstmt = conn.prepareStatement(sql);
                pstmt.setString(1, name);
                rs = pstmt.executeQuery();
                if(rs.next()) {
                    Member member = new Member();
                    member.setId(rs.getLong("id"));
                    member.setName(rs.getString("name"));
                    return Optional.of(member);
                }
    
                return Optional.empty();
            } catch (Exception e) {
                throw new IllegalStateException(e);
            } finally {
                close(conn, pstmt, rs);
            }
        }
        private Connection getConnection() {
            // Spring을 통해 Data Connection을 할 경우 DataSourceUtils 통해 해야함
            // 트랜잭션을 유지해줌
            return DataSourceUtils.getConnection(dataSource);
        }
        private void close(Connection conn, PreparedStatement pstmt, ResultSet rs)
        {
            try {
                if (rs != null) {
                    rs.close();
                }
            } catch (SQLException e) {
                e.printStackTrace();
            } try {
            if (pstmt != null) {
                pstmt.close();
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }
            try {
                if (conn != null) {
                    close(conn);
                }
            } catch (SQLException e) {
                e.printStackTrace();
            } }
        private void close(Connection conn) throws SQLException {
            DataSourceUtils.releaseConnection(conn, dataSource);
        }
    }
    ```
    
- Spring Configuration에 추가
    
    ```java
    private DataSource dataSource;
    
    @Autowired
    public SpringConfig(DataSource dataSource) {
        this.dataSource = dataSource;
    }
    
    @Bean
    public MemberRepository memberRepository() {
        //return new MemoryMemberRepository();
        return new JdbcMemberRepository(dataSource);
    
    }
    ```
    

## Spring 통합 테스트

- 스프링 컨테이너와 DB까지 연결한 통합 테스트를 진행
- MemberServiceIntegrationTest 추가
    
    ```java
    package com.example.demo.service;
    
    import static org.junit.jupiter.api.Assertions.assertEquals;
    import static org.junit.jupiter.api.Assertions.assertThrows;
    
    @SpringBootTest //스프링 컨테이너와 테스트를 함께 실행
    @Transactional 
    //테스트 시작 전에 트랜잭션을 시작하고, 테스트 완료 후에 항상 롤백한다. 
    //이렇게 하면 DB에 데이터가 남지 않으므로 다음 테스트에 영향을 주지 않는다.
    class MemberServiceIntegrationTest {
    
        @Autowired
        MemberService memberService;
    
        @Autowired
        MemberRepository memberRepository;
    
        @Test
        void join() {
    
            //given
            Member member = new Member();
            member.setName("user");
    
            //when
            Long savedId = memberService.join(member);
            Member findMember = memberService.findOne(savedId).get();
    
            //then
            assertEquals(member.getName(), findMember.getName()); //static import
    
        }
    
        @Test
        void duplicate_member_join() {
    
            //given
            Member member1 = new Member();
            member1.setName("user");
    
            Member member2 = new Member();
            member2.setName("user");
    
            //when
            memberService.join(member1);
    
            //then
            assertThrows(IllegalStateException.class,
                    () -> memberService.join(member2));
    
        }
    
    }
    ```
    

## Spring JdbcTemplate

- 순수 JDBC와 동일한 환경에서 수행 →  관련 라이브러리 추가 및 DB 연결 설정 추가
- JdbcTemplate과 MyBatis 같은 라이브러리는 JDBC API의 반복 코드를 대부분 제거해 줌(SQL은 직접 작성해야 함)
- JdbcTemplateMemberRepository 추가
    
    ```java
    package com.example.demo.repository;
    
    public class JdbcTemplateMemberRepository implements MemberRepository {
        private final JdbcTemplate jdbcTemplate;
    
        //생성자가 1개 이므로 @Autowired 생략 가능
        public JdbcTemplateMemberRepository(DataSource dataSource) {
            jdbcTemplate = new JdbcTemplate(dataSource);
        }
        @Override
        public Member save(Member member) {
    
            SimpleJdbcInsert jdbcInsert = new SimpleJdbcInsert(jdbcTemplate);
            jdbcInsert.withTableName("member").usingGeneratedKeyColumns("id");
    
            Map<String, Object> parameters = new HashMap<>();
            parameters.put("name", member.getName());
            Number key = jdbcInsert.executeAndReturnKey(new
                    MapSqlParameterSource(parameters));
            member.setId(key.longValue());
    
            return member;
        }
        @Override
        public Optional<Member> findById(Long id) {
            List<Member> result = jdbcTemplate
                    .query("select * from member where id = ?", 
                            memberRowMapper(), id);
            return result.stream().findAny();
        }
        @Override
        public List<Member> findAll() {
            return jdbcTemplate.query("select * from member", 
                    memberRowMapper());
        }
        @Override
        public Optional<Member> findByName(String name) {
            List<Member> result = jdbcTemplate
                    .query("select * from member where name = ?",
                            memberRowMapper(), name);
            return result.stream().findAny();
        }
        private RowMapper<Member> memberRowMapper() {
            return (rs, rowNum) -> { //lambda style
    
                Member member = new Member();
                member.setId(rs.getLong("id"));
                member.setName(rs.getString("name"));
    
                return member;
            };
        }
    }
    ```
    
- Spring의 Configuration 수정
    
    ```java
    @Bean
        public MemberRepository memberRepository() {
            //return new MemoryMemberRepository();
            //return new JdbcMemberRepository(dataSource);
            return new JdbcTemplateMemberRepository(dataSource);
        }
    ```
    

## JPA(Java Persistence API)

- 장점
    - 기존의 반복 코드는 물론이고, 기본적인 SQL도 JPA가 직접 만들어서 실행해 줌
    - SQL과 데이터 중심의 설계에서 객체 중심의 설계로 패러다임을 전환을 할 수 있음
    - 개발 생산성을 크게 높일 수 있음
- build.gradle 파일에 JPA, h2 데이터베이스 관련 라이브러리 추가
    
    ```kotlin
    dependencies {
    	implementation("org.springframework.boot:spring-boot-starter")
    	testImplementation("org.springframework.boot:spring-boot-starter-test")
    	implementation("org.springframework.boot:spring-boot-starter-web")
    	implementation("org.springframework.boot:spring-boot-starter-thymeleaf")
    	//implementation("org.springframework.boot:spring-boot-starter-jdbc")
    	//spring-boot-starter-data-jpa 는 내부에 jdbc 관련 라이브러리를 
    	//포함 하므로 jdbc는 제거해도 됨
    	implementation("org.springframework.boot:spring-boot-starter-data-jpa")
    	runtimeOnly("com.h2database:h2")
    }
    ```
    
- resources/application.properties에 JPA 설정 추가
    
    ```
    spring.jpa.show-sql=true
    # JPA가 생성하는 SQL을 출력
    spring.jpa.hibernate.ddl-auto=none
    # JPA는 테이블을 자동으로 생성하는 기능을 제공하는데 none 을 사용하면 해당 기능을 끔
    # create를 사용하면 엔티티 정보를 바탕으로 테이블도 직접 생성해줌
    ```
    
- Member의 JPA Entity Mapping
    
    ```java
    package com.example.demo.domain;
    
    @Entity //JPA가 관리하는 Entity
    public class Member {
        @Id @GeneratedValue(strategy =  GenerationType.IDENTITY)
        //@Id -> Primary key
        //@GeneratedValue(strategy =  GenerationType.IDENTITY) -> DB가 id 값을 알아서 생성
        private Long id;
    
        //DB와 Column 명이 다르다면 @Column을 통해 DB와 Mapping 함,
        private String name;
    
        //이하 코드 생략
    }
    ```
    
- JpaMemberRepository 추가
    
    ```java
    package com.example.demo.repository;
    
    public class JpaMemberRepository implements MemberRepository {
    
        private final EntityManager em;
    
        public JpaMemberRepository(EntityManager em) {
            this.em = em;
        }
    
        public Member save(Member member) {
            em.persist(member); //em을 통해 member 저장 -> 쿼리 자동 생성
            return member;
        }
    
        public Optional<Member> findById(Long id) {
            Member member = em.find(Member.class, id); //em을 통해 조회
            return Optional.ofNullable(member);
        }
    
        public Optional<Member> findByName(String name) {
            List<Member> result = em.
                    createQuery("select m from Member m where m.name = :name",
                            Member.class)
                    .setParameter("name", name)
                    .getResultList();
            return result.stream().findAny();
            //JPQL 이라는 SQL과 유살한 객체지향 언어를 통해 객체를 대상으로 쿼리
        }
    
        public List<Member> findAll() {
            return em.createQuery("select m from Member m", Member.class)
                    .getResultList(); //JPQL 쿼리
        }
    
    }
    ```
    
- MemberService에 Transaction 추가
    
    ```java
    // 스프링은 해당 클래스의 메서드를 실행할 때 트랜잭션을 시작하고,
    // 메서드가 정상 종료되면 트랜잭션을 Commit함. 만약 런타임 예외가 발생하면 롤백.
    // JPA를 통한 모든 데이터 변경은 트랜잭션 안에서 실행해야 함
    @Transactional
    public class MemberService {
    	//코드 생략
    }
    ```
    
- SpringConfig 수정
    
    ```java
    private final EntityManager em;
    
    public SpringConfig(EntityManager em) {
        this.em = em;
    }
    
     @Bean
      public MemberService memberService() {
          return new MemberService(memberRepository());
     }
    
    @Bean
    public MemberRepository memberRepository() {
        //return new MemoryMemberRepository();
        //return new JdbcMemberRepository(dataSource);
        //return new JdbcTemplateMemberRepository(dataSource);
    	    return new JpaMemberRepository(em);
    }
    ```
    

## Spring 데이터 JPA

- 기존의 한계를 넘어 마치 마법처럼, Repository에 구현 클래스 없이 interface 만으로 개발 가능
- 위의 JPA 방식과 동일한 환경에서 적용
- 실무에서는 JPA와 스프링 데이터 JPA를 기본으로 사용하고, 복잡한 동적 쿼리는 Querydsl이라는 라이브러리를 사용하면 됨
- SpringDataJpaMemberRepository 추가
    
    ```java
    package com.example.demo.repository;
    
    public interface SpringDataJpaMemberRepository
            extends MemberRepository, JpaRepository<Member,Long> { 
    
    		// JpaRepository<Member,Long> -> Long type은 Id를 의미
    		// 스프링 데이터 JPA가 SpringDataJpaMemberRepository를 스프링 빈으로 자동 등록
    		// 또한 save, findAll, findById 등의 메소드 + CRUD는 JpaRepository에서 
    		// 기본적으로 제공 -> 기존에 포함되지 않은 findByName 부분만 정의해주면 됨
        Optional<Member> findByName(String name);
    		// reflection을 통해 데이터 타입과 함수명 등으로 간단한 경우는 쿼리를 자동 제작
    
    }
    ```
    
- SpringConfig ****수정
    
    ```java
    package com.example.demo;
    
    @Configuration
    public class SpringConfig {
    
        /*
        private DataSource dataSource;
    
        private final EntityManager em;
    
        @Autowired
        public SpringConfig(DataSource dataSource, EntityManager em) {
            this.dataSource = dataSource;
            this.em = em;
        }
    
         */
    
        private final MemberRepository memberRepository;
    
        @Autowired
        public SpringConfig(MemberRepository memberRepository) {
            this.memberRepository = memberRepository;
        }
    
        /*
        @Bean
        public MemberRepository memberRepository() {
            //return new MemoryMemberRepository();
            //return new JdbcMemberRepository(dataSource);
            //return new JdbcTemplateMemberRepository(dataSource);
            return new JpaMemberRepository(em);
        }
         */
    
        @Bean
        public MemberService memberService() {
    
            //return new MemberService(memberRepository());
            return new MemberService(memberRepository);
        }
    
    }
    ```